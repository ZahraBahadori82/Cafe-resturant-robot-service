<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cafe Robot Orders Database</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .header h1 {
            color: #4a5568;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-badge {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .logout-btn {
            background: linear-gradient(45deg, #f56565, #e53e3e);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .logout-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245, 101, 101, 0.3);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .stat-card {
            background: #ffffff;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            min-width: 120px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(45deg, #4662e0, #3a175d);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.active {
            background: linear-gradient(45deg, #48bb78, #38a169);
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: white;
            font-size: 1.2rem;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .orders-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .order-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .order-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(45deg, #667eea, #764ba2);
        }

        .order-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .order-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .order-id {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4a5568;
        }

        .order-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .status-pending { background: #fed7d7; color: #c53030; }
        .status-preparing { background: #feebc8; color: #dd6b20; }
        .status-ready { background: #c6f6d5; color: #38a169; }
        .status-delivered { background: #bee3f8; color: #3182ce; }
        .status-cancelled { background: #e2e8f0; color: #718096; }

        .order-info {
            margin-bottom: 15px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .info-label {
            color: #666;
            font-weight: 500;
        }

        .info-value {
            color: #333;
            font-weight: 600;
        }

        .order-items {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .items-title {
            font-weight: bold;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .item:last-child {
            border-bottom: none;
        }

        .item-name {
            font-weight: 500;
        }

        .item-quantity {
            color: #666;
            margin-left: 10px;
        }

        .item-price {
            font-weight: bold;
            color: #667eea;
        }

        .order-total {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #e2e8f0;
            text-align: right;
        }

        .total-amount {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        .order-time {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
            text-align: center;
        }

        .no-orders {
            text-align: center;
            padding: 50px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            color: #666;
        }

        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.5s ease;
            max-width: 350px;
            animation: shake 0.8s ease-in-out;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification-header {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .notification-body {
            font-size: 0.9rem;
            line-height: 1.4;
        }

        @keyframes shake {
            0%, 20%, 40%, 60%, 80%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(10px); }
        }

        .order-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #ffffff;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-confirm {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }

        .btn-preparing {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
        }

        .btn-ready {
            background: linear-gradient(45deg, #4299e1, #3182ce);
        }

        .btn-delivered {
            background: linear-gradient(45deg, #9f7aea, #805ad5);
        }

        .btn-cancel {
            background: linear-gradient(45deg, #f56565, #e53e3e);
        }

        .btn-resend-robot {
            background: linear-gradient(45deg, #667eea, #764ba2);
        }

        .btn-goto-table {
            background: linear-gradient(45deg, #38a169, #2f855a);
        }

        .btn-waiting {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .btn-waiting:hover {
            transform: none;
            box-shadow: none;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .content-section {
            display: none;
            background: #fff;
            padding: 18px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.06);
            margin-top: 20px;
        }

        .content-section.active {
            display: block;
        }

        .btn-action {
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 0 4px;
            color: white;
            font-weight: 600;
        }

        .btn-edit {
            background: #3182ce;
        }

        .btn-delete {
            background: #e53e3e;
        }

        .btn-add {
            background: #48bb78;
            padding: 8px 12px;
            border-radius: 8px;
            color: white;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
        }

        th, td {
            padding: 10px;
            border-bottom: 1px solid #eee;
            text-align: center;
        }

        .mqtt-status-inline {
            font-size: 0.8rem;
            padding: 5px 10px;
            border-radius: 5px;
            margin-top: 5px;
        }

        .mqtt-status-inline.connected {
            background: #c6f6d5;
            color: #38a169;
        }

        .mqtt-status-inline.disconnected {
            background: #fed7d7;
            color: #c53030;
        }

        .robot-delivery-status {
            font-size: 0.8rem;
            padding: 5px 10px;
            border-radius: 5px;
            margin-top: 5px;
            text-align: center;
        }

        .unauthorized {
            text-align: center;
            padding: 50px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            color: #e53e3e;
            font-size: 1.2rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .user-info {
                position: static;
                justify-content: center;
                margin-top: 15px;
            }
            
            .stats {
                gap: 15px;
            }
            
            .controls {
                gap: 10px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
            
            .orders-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .order-card {
                padding: 20px;
            }
        }
        /* ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ ÿß€åŸÜ CSS ÿ±Ÿà ÿ®Ÿá ŸÅÿß€åŸÑ dashboard */

        /* Role indicator ÿØÿ± header */
        .role-indicator {
        background: linear-gradient(45deg, #28a745, #20c997);
        color: white;
        padding: 5px 12px;
        border-radius: 15px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        margin-left: 10px;
        }

        .role-indicator.kitchen {
        background: linear-gradient(45deg, #fd7e14, #e06f00);
        }

        .role-indicator.manager {
        background: linear-gradient(45deg, #6f42c1, #5a32a3);
        }

        .role-indicator.robot {
        background: linear-gradient(45deg, #17a2b8, #138496);
        }

        .role-indicator.admin {
        background: linear-gradient(45deg, #dc3545, #c82333);
        }

        /* ŸÖÿÆŸÅ€å ⁄©ÿ±ÿØŸÜ ÿßŸÑŸÖÿßŸÜ‚ÄåŸáÿß ÿ®ÿ± ÿßÿ≥ÿßÿ≥ role */
        .hidden-by-role {
        display: none !important;
        }

        /* Disabled state ÿ®ÿ±ÿß€å ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤ */
        .btn-disabled-by-role {
        opacity: 0.4 !important;
        cursor: not-allowed !important;
        pointer-events: none !important;
        }

        /* Highlighted filter ÿ®ÿ±ÿß€å role ŸÖÿÆÿµŸàÿµ */
        .filter-btn.role-default {
        background: linear-gradient(45deg, #28a745, #20c997) !important;
        color: white !important;
        box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        transform: translateY(-2px);
        }

        /* ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ÿ®ÿ±ÿØÿ± ÿ±ŸÜ⁄Ø€å ÿ®ÿ±ÿß€å ŸÜÿ¥ÿßŸÜ ÿØÿßÿØŸÜ access level */
        .order-card.role-kitchen {
        border-left: 4px solid #fd7e14;
        }

        .order-card.role-manager {
        border-left: 4px solid #6f42c1;
        }

        .order-card.role-robot {
        border-left: 4px solid #17a2b8;
        }

        .order-card.role-admin {
        border-left: 4px solid #dc3545;
        }

        /* Ÿæ€åÿßŸÖ ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿØÿ≥ÿ™ÿ±ÿ≥€å */
        .access-denied-message {
        background: #f8d7da;
        color: #721c24;
        padding: 12px 20px;
        border-radius: 8px;
        margin: 20px 0;
        text-align: center;
        border: 1px solid #f5c6cb;
        }

        /* ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ŸÜÿ¥ÿßŸÜ⁄Øÿ± role ÿØÿ± stats cards */
        .stat-card.role-restricted {
        opacity: 0.6;
        position: relative;
        }

        .stat-card.role-restricted::after {
        content: "ŸÖÿ≠ÿØŸàÿØ ÿ¥ÿØŸá";
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(220, 53, 69, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        }

        /* ÿ≥ÿ®⁄© ŸÖÿÆÿµŸàÿµ Kitchen Role */
        .dashboard.kitchen-mode {
        --primary-color: #fd7e14;
        }

        .dashboard.kitchen-mode .filter-btn.active {
        background: var(--primary-color);
        }

        /* ÿ≥ÿ®⁄© ŸÖÿÆÿµŸàÿµ Manager Role */
        .dashboard.manager-mode {
        --primary-color: #6f42c1;
        }

        .dashboard.manager-mode .filter-btn.active {
        background: var(--primary-color);
        }

        /* ÿ≥ÿ®⁄© ŸÖÿÆÿµŸàÿµ Robot Role */
        .dashboard.robot-mode {
        --primary-color: #17a2b8;
        }

        .dashboard.robot-mode .filter-btn.active {
        background: var(--primary-color);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
        .role-indicator {
            font-size: 10px;
            padding: 3px 8px;
        }
        
        .access-denied-message {
            padding: 8px 12px;
            font-size: 14px;
        }
        }
        .search-container {
             position: relative;
             margin: 20px auto; 
             width: 75%; 
             max-width: 600px;
             min-width: 300px;
        }

        .search-input {
            width: 100%;
            padding: 12px 45px 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 25px;
            font-size: 14px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(10px);
            box-sizing: border-box; 
            }

            .search-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none; /* ÿ™ÿß ÿ±Ÿà€å input ⁄©ŸÑ€å⁄© ⁄©ÿßÿ±ÿ®ÿ± ŸÖÿ¥⁄©ŸÑ ŸÜÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥Ÿá */
            }

             .search-icon img {
            width: 18px;
            height: 18px;
            opacity: 0.6;
            }

            .search-input:focus {
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            }

            @media (max-width: 768px) {
                .stats-grid {
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                }
                
                .stat-card.hidden {
                    display: none !important;
                }
            }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="user-info">
                <div class="user-badge" id="userBadge">Loading...</div>
                <button class="logout-btn" onclick="logout()">ÿÆÿ±Ÿàÿ¨</button>
            </div>
            
            <h1>ü§ñ Cafe Robot Orders</h1>
            <p>Database Management Dashboard</p>
            
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalOrders">-</div>
                    <div class="stat-label">Total Orders</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="pendingOrders">-</div>
                    <div class="stat-label">Pending</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="completedOrders">-</div>
                    <div class="stat-label">Delivered</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="managementUsers">-</div>
                    <div class="stat-label">Management User</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalRevenue">$-</div>
                    <div class="stat-label">Total Revenue</div>
                </div>
            </div>
        </div>
        <div class="search-container">
        <input type="text" id="orderSearch" placeholder="Search orders by ID, table, or items..." class="search-input">
        <i class="fa-solid fa-magnifying-glass search-icon"></i>        
        </div>

        <div class="controls">
            <button class="btn active" onclick="filterOrders('all', this)">All Orders</button>
            <button class="btn" onclick="filterOrders('pending', this)">Pending</button>
            <button class="btn" onclick="filterOrders('preparing', this)">Preparing</button>
            <button class="btn" onclick="filterOrders('ready', this)">Ready</button>
            <button class="btn" onclick="filterOrders('delivered', this)">Delivered</button>
            <button class="btn" onclick="switchTab('users', this)" id="usersTab" style="display: none;">üë§ Users Management</button>
            <button class="btn" onclick="switchTab('testing', this)">üß™ Robot Testing</button>
            <button class="btn" onclick="refreshOrders()">üîÑ Refresh</button>
        </div>

        <div id="users" class="content-section">
            <h2>User Management</h2>
            <button class="btn-action btn-add" onclick="addUser()">‚ûï Add User</button>
            <table>
                <thead>
                <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Role</th>
                    <th>Actions</th>
                </tr>
                </thead>
                <tbody id="usersTable">
                <tr><td colspan="4">Loading...</td></tr>
                </tbody>
            </table>
        </div>

        <div id="testing" class="content-section">
            <h2>üß™ Robot Testing & Simulation</h2>
            <p>This section allows you to test the robot delivery workflow without a real robot connected.</p>
            
            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;">
                <h3>Delivery Simulation</h3>
                <p>Test the complete delivery workflow:</p>
                <ol>
                    <li>Create an order and move it to "Ready" status</li>
                    <li>Click "Simulate Robot Pickup" to simulate robot starting delivery</li>
                    <li>Watch the button change to "Waiting for Delivery..."</li>
                    <li>After 10 seconds, order automatically moves to "Delivered"</li>
                </ol>
                
                <div style="margin: 15px 0;">
                    <input type="number" id="testOrderId" placeholder="Enter Order ID" 
                        style="padding: 8px; border-radius: 5px; border: 1px solid #ccc; margin-right: 10px;">
                    <button class="btn" onclick="simulateRobotDelivery(document.getElementById('testOrderId').value)">
                        üöõ Simulate Robot Pickup
                    </button>
                </div>
            </div>

            <div style="background: #e6f3ff; padding: 20px; border-radius: 10px; margin: 20px 0;">
                <h3>MQTT Topics Information</h3>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: #f0f0f0;">
                        <th style="padding: 10px; border: 1px solid #ddd;">Action</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">MQTT Topic</th>
                        <th style="padding: 10px; border: 1px solid #ddd;">Description</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">Order ‚Üí Preparing</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">kitchen/order/preparing</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Notifies kitchen to start preparing</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">Order ‚Üí Ready</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">robot/delivery/pickup</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Sends order to robot for delivery</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">Robot Delivering</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">robot/status/delivering</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Robot confirms pickup & delivery start</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">Delivery Complete</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">robot/delivery/complete</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Robot confirms delivery completion</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #ddd;">Order ‚Üí Delivered</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">customer/notification/delivered</td>
                        <td style="padding: 10px; border: 1px solid #ddd;">Notifies customer of completed delivery</td>
                    </tr>
                </table>
            </div>

            <div style="background: #fff3cd; padding: 20px; border-radius: 10px; margin: 20px 0;">
                <h3>Current Delivery States</h3>
                <div id="deliveryStatesDisplay">
                    <p>No active deliveries</p>
                </div>
                <button class="btn" onclick="updateDeliveryStatesDisplay()" style="margin-top: 10px;">
                    üîÑ Refresh States
                </button>
            </div>
        </div>

        <div id="orders" class="content-section active">
            <div id="loading" class="loading" style="display: none;">
                <div class="spinner"></div>
                Loading orders...
            </div>

            <div id="errorMessage" class="error-message" style="display: none;"></div>

            <div id="ordersContainer">
                <div class="no-orders">
                    <h3>No orders found</h3>
                    <p>Click refresh to load orders from the database</p>
                </div>
            </div>
        </div>

        <div id="notification" class="notification">
            <div class="notification-header">
                üîî New Order!
            </div>
            <div class="notification-body" id="notificationBody">
                New order received
            </div>
        </div>
    </div>


     <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script>
       let allOrders = [];
        let currentFilter = 'all';
        let lastOrderCount = 0;
        let mqttConnected = false;
        let socket = null;
        let connectionAttempts = 0;
        const maxConnectionAttempts = 5;
        let deliveryStates = {}; // Track delivery states for each order
        let currentUser = null;

        // API Base URL
        const API_BASE = '/api/orders';
        const API_USERS = '/api/users';
        const API_AUTH = '/api/auth';
        // Search functionality
            // ÿ¨ÿß€å⁄Øÿ≤€åŸÜ search function ŸÖŸàÿ¨ŸàÿØ ÿ®ÿß ÿß€åŸÜ:
    document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('orderSearch');
    
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase().trim();
            
            // ÿß⁄Øÿ± search ÿÆÿßŸÑ€å ÿ®ÿßÿ¥ÿØÿå ŸáŸÖŸá ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß ÿ±ÿß ŸÜÿ¥ÿßŸÜ ÿ®ÿØŸá
            if (!searchTerm) {
                document.querySelectorAll('.order-card').forEach(card => {
                    card.style.display = 'block';
                });
                // ÿ≠ÿ∞ŸÅ Ÿæ€åÿßŸÖ no results
                const existingMessage = document.querySelector('.no-results-message');
                if (existingMessage) existingMessage.remove();
                return;
            }
            
            // Ÿæ€åÿØÿß ⁄©ÿ±ÿØŸÜ Ÿà ŸÅ€åŸÑÿ™ÿ± ⁄©ÿ±ÿØŸÜ ⁄©ÿßÿ±ÿ™‚ÄåŸáÿß
            const orderCards = document.querySelectorAll('.order-card');
            let visibleCount = 0;
            
            orderCards.forEach(card => {
                const cardText = card.textContent.toLowerCase();
                const shouldShow = cardText.includes(searchTerm);
                
                card.style.display = shouldShow ? 'block' : 'none';
                if (shouldShow) visibleCount++;
            });
            
            // ŸÜŸÖÿß€åÿ¥/ÿ≠ÿ∞ŸÅ Ÿæ€åÿßŸÖ no results
            updateSearchResults(searchTerm, visibleCount);
        });
    }
    
    // ÿ®ŸÇ€åŸá initialization
    fetch('/api/auth/status')
        .then(response => response.json())
        .then(data => {
            if (data.authenticated) {
                currentUser = data.user;
                applyRoleRestrictions(data.user.role);
                applyDefaultFilter(data.user.role);
            }
        })
        .catch(error => {
            console.error('Auth check failed:', error);
        });
    });

    function updateSearchResults(searchTerm, visibleCount) {
    const existingMessage = document.querySelector('.no-results-message');
    if (existingMessage) existingMessage.remove();
    
    if (searchTerm && visibleCount === 0) {
        const message = document.createElement('div');
        message.className = 'no-results-message';
        message.innerHTML = `<p>Ÿá€å⁄Ü ÿ≥ŸÅÿßÿ±ÿ¥€å ÿ®ÿß "${searchTerm}" Ÿæ€åÿØÿß ŸÜÿ¥ÿØ.</p>`;
        message.style.cssText = `
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin: 20px;
        `;
        
        const container = document.getElementById('ordersContainer') || document.querySelector('.orders-container');
        if (container) {
            container.appendChild(message);
        }
        }
    }  
    
    function setActiveFilter(filterType) {
    // Ÿæ€åÿØÿß ⁄©ÿ±ÿØŸÜ ÿØ⁄©ŸÖŸá ŸÖÿ±ÿ®Ÿàÿ∑Ÿá
        const filterButton = document.querySelector(`[data-filter="${filterType}"], .btn[onclick*="${filterType}"]`);
        
        if (filterButton) {
            filterButton.click();
        } else {
            // ÿß⁄Øÿ± ÿØ⁄©ŸÖŸá Ÿæ€åÿØÿß ŸÜÿ¥ÿØÿå ŸÖÿ≥ÿ™ŸÇ€åŸÖÿßŸã ŸÅ€åŸÑÿ™ÿ± ÿ±ÿß ÿßÿπŸÖÿßŸÑ ⁄©ŸÜ
            currentFilter = filterType;
            filterOrdersByStatus(filterType);
            
            // ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿØ⁄©ŸÖŸá
            document.querySelectorAll('.controls .btn').forEach(btn => btn.classList.remove('active'));
            const allButtons = document.querySelectorAll('.controls .btn');
            allButtons.forEach(btn => {
                if (btn.textContent.toLowerCase().includes(filterType) || btn.onclick?.toString().includes(filterType)) {
                    btn.classList.add('active');
                }
            });
        }
    }
                 
        function applyRoleRestrictions(userRole) {
            const permissions = rolePermissions[userRole];
            
            if (!permissions.canViewAllStats) {
                // ŸÖÿÆŸÅ€å ⁄©ÿ±ÿØŸÜ stats ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá
                if (permissions.hideStats) {
                    permissions.hideStats.forEach(statName => {
                        hideStatCard(statName);
                    });
                }
            }
        }

        function hideStatCard(statName) {
            const statMappings = {
                'managementUsers': '.stat-card:nth-child(4)', // Management User card
                'totalRevenue': '.stat-card:nth-child(5)'      // Total Revenue card
            };
            
            const selector = statMappings[statName];
            if (selector) {
                const element = document.querySelector(selector);
                if (element) {
                    element.style.display = 'none';
                }
            }
        }

        // ÿßÿπŸÖÿßŸÑ ŸÖÿ≠ÿØŸàÿØ€åÿ™‚ÄåŸáÿß ŸáŸÜ⁄ØÿßŸÖ ŸÑŸàÿØ ÿµŸÅÿ≠Ÿá
        document.addEventListener('DOMContentLoaded', function() {
            // ⁄Øÿ±ŸÅÿ™ŸÜ role ⁄©ÿßÿ±ÿ®ÿ± (ÿßÿ≤ session €åÿß API)
            fetch('/api/auth/status')
                .then(response => response.json())
                .then(data => {
                    if (data.authenticated) {
                        applyRoleRestrictions(data.user.role);
                        applyDefaultFilter(data.user.role);
                    }
                });
        });

        function applyDefaultFilter(userRole) {
            const permissions = rolePermissions[userRole];
            
            if (permissions.defaultFilter) {
                // ÿ™ŸÜÿ∏€åŸÖ ŸÅ€åŸÑÿ™ÿ± Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂
                setActiveFilter(permissions.defaultFilter);
            }
            
            // ŸÖÿÆŸÅ€å ⁄©ÿ±ÿØŸÜ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤
            const allButtons = document.querySelectorAll('.filter-btn');
            allButtons.forEach(btn => {
                const filterType = btn.dataset.filter;
                if (!permissions.buttons.includes(filterType)) {
                    btn.style.display = 'none';
                }
            });
        }
        // Authentication functions
        async function checkAuth() {
            try {
                const response = await fetch(`${API_AUTH}/status`);
                const data = await response.json();
                
                if (data.authenticated) {
                    currentUser = data.user;
                    updateUIForUser();
                    return true;
                } else {
                    window.location.href = '/login';
                    return false;
                }
            } catch (error) {
                console.error('Auth check failed:', error);
                window.location.href = '/login';
                return false;
            }
        }

        function updateUIForUser() {
            if (!currentUser) return;
            
            const userBadge = document.getElementById('userBadge');
            userBadge.textContent = `${currentUser.role.toUpperCase()} - ${currentUser.username}`;
            
            // Show/hide features based on role
            const usersTab = document.getElementById('usersTab');
            if (currentUser.role === 'admin') {
                usersTab.style.display = 'inline-block';
            }
        }

        async function logout() {
            if (confirm('ÿ¢€åÿß ŸÖÿ∑ŸÖÿ¶ŸÜ Ÿáÿ≥ÿ™€åÿØ ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿÆÿßÿ±ÿ¨ ÿ¥Ÿà€åÿØÿü')) {
                try {
                    await fetch(`${API_AUTH}/logout`);
                    window.location.href = '/login';
                } catch (error) {
                    console.error('Logout error:', error);
                    window.location.href = '/login';
                }
            }
        }

        function playNotificationSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Audio playback failed:', error);
            }
        }

        function showNewOrderNotification(order) {
            if (!order) return;
            
            const notification = document.getElementById('notification');
            const notificationBody = document.getElementById('notificationBody');
            
            let items = [];
            try {
                items = Array.isArray(order.items) ? order.items : JSON.parse(order.items || '[]');
            } catch (e) {
                items = [];
            }
            
            const itemsList = items.map(item => 
                `${item.name || 'Unknown'} x${item.quantity || item.count || 1}`
            ).join(', ');
            
            notificationBody.innerHTML = `
                <strong>Order #${order.id}</strong><br>
                Table: ${order.tableId}<br>
                Items: ${itemsList}<br>
                Total: $${parseFloat(order.totalPrice || 0).toFixed(2)}
            `;
            
            notification.classList.add('show');
            playNotificationSound();
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 7000);
        }

        function getStatusText(status) {
            const statusTexts = {
                'pending': 'Pending',
                'preparing': 'Preparing', 
                'ready': 'Ready for Delivery',
                'delivered': 'Delivered',
                'cancelled': 'Cancelled'
            };
            return statusTexts[status] || status;
        }

        async function updateOrderStatus(orderId, newStatus) {
            if (!currentUser) {
                showError('Authentication required');
                return;
            }

            try {
                const orderCard = document.querySelector(`[data-order-id="${orderId}"]`) || 
                                Array.from(document.querySelectorAll('.order-card')).find(card => 
                                    card.innerHTML.includes(`Order #${orderId}`));
                
                if (orderCard) {
                    const actionButtons = orderCard.querySelector('.order-actions');
                    if (actionButtons) {
                        const originalContent = actionButtons.innerHTML;
                        actionButtons.innerHTML = '<div>‚è≥ Processing...</div>';
                        
                        setTimeout(() => {
                            if (actionButtons.innerHTML.includes('Processing')) {
                                actionButtons.innerHTML = originalContent;
                            }
                        }, 3000);
                    }
                }
                
                const response = await fetch(`${API_BASE}/${orderId}/status`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ status: newStatus })
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        window.location.href = '/login';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    console.log(`‚úÖ Order #${orderId} status updated to '${newStatus}' by ${currentUser.username}`);
                    showSuccessMessage(`Order #${orderId} status changed to "${getStatusText(newStatus)}"`);
                    
                    // Send MQTT messages for different status changes
                    const order = allOrders.find(o => o.id === orderId);
                    if (order) {
                        await sendMQTTStatusUpdate(orderId, newStatus, order);
                    }
                    
                    if (newStatus === 'ready') {
                        if (result.robotNotified) {
                            showSuccessMessage(`ü§ñ Order #${orderId} sent to robot`);
                        } else if (!mqttConnected) {
                            showWarningMessage(`‚ö†Ô∏è Order is ready but robot is not connected!`);
                        } else {
                            showWarningMessage(`‚ö†Ô∏è Error sending order to robot`);
                        }
                    }
                    
                    await fetchOrders();
                    
                } else {
                    throw new Error(result.message || 'Failed to update status');
                }
            } catch (error) {
                console.error('Status update error:', error);
                if (error.message.includes('401') || error.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    showError(`Error updating status: ${error.message}`);
                    await fetchOrders();
                }
            }
        }

        async function sendMQTTStatusUpdate(orderId, status, order) {
            try {
                if (!mqttConnected || !socket) {
                    console.log('MQTT not connected, skipping status update');
                    return;
                }

                const mqttData = {
                    orderId: orderId,
                    status: status,
                    tableId: order.tableId,
                    timestamp: new Date().toISOString()
                };

                switch(status) {
                    case 'preparing':
                        // Send to kitchen topic
                        socket.emit('send_to_kitchen', {
                            orderId: orderId,
                            tableId: order.tableId,
                            items: typeof order.items === 'string' ? JSON.parse(order.items) : order.items,
                            totalPrice: order.totalPrice,
                            timestamp: new Date().toISOString(),
                            action: 'start_preparing'
                        });
                        showSuccessMessage(`üç≥ Order #${orderId} sent to kitchen`);
                        break;

                    case 'delivered':
                        // Send to customer/table topic
                        socket.emit('notify_customer', {
                            orderId: orderId,
                            tableId: order.tableId,
                            message: `Your order #${orderId} has been delivered!`,
                            totalPrice: order.totalPrice,
                            timestamp: new Date().toISOString(),
                            action: 'order_delivered'
                        });
                        showSuccessMessage(`üì± Customer at Table ${order.tableId} notified of delivery`);
                        break;
                }

                console.log(`üì° MQTT status update sent for order #${orderId}: ${status}`);
                
            } catch (error) {
                console.error('Error sending MQTT status update:', error);
            }
        }

        async function sendOrderToRobot(orderId) {
            if (!currentUser) {
                showError('Authentication required');
                return;
            }

            try {
                if (!mqttConnected) {
                    showError('Robot is not connected! Please check MQTT connection.');
                    return;
                }
                
                const order = allOrders.find(o => o.id === orderId);
                if (!order) {
                    throw new Error('Order not found');
                }
                
                if (order.status !== 'ready') {
                    showError(`Only ready orders can be sent to robot. Current status: ${getStatusText(order.status)}`);
                    return;
                }

                showSuccessMessage(`‚è≥ Sending order #${orderId} to robot...`);

                let items = [];
                try {
                    items = typeof order.items === 'string' ? JSON.parse(order.items || '[]') : order.items;
                } catch (e) {
                    items = [];
                }

                const robotOrderData = {
                    id: order.id,
                    table_id: order.tableId,
                    table_location: order.tableLocation || `Table ${order.tableId} Location`,
                    items: items,
                    total_price: order.totalPrice,
                    priority: 'normal',
                    created_at: order.created_at,
                    manual_send: true
                };

                if (socket && socket.connected) {
                    socket.emit('send_order_to_robot', { orderData: robotOrderData });
                } else {
                    const response = await fetch(`/api/mqtt/robot/send-order/${orderId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(robotOrderData)
                    });
                    
                    if (!response.ok) {
                        if (response.status === 401) {
                            window.location.href = '/login';
                            return;
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    if (!result.success) {
                        throw new Error(result.message);
                    }
                    
                    showSuccessMessage(`ü§ñ Order #${orderId} successfully sent to robot`);
                }
                
                console.log(`‚úÖ Order #${orderId} sent to robot (manual) by ${currentUser.username}`);
                
            } catch (error) {
                console.error('Error sending order to robot:', error);
                if (error.message.includes('401') || error.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    showError(`Error sending to robot: ${error.message}`);
                }
            }
        }

        async function sendRobotToTable(tableNumber) {
            if (!currentUser) {
                showError('Authentication required');
                return;
            }

            try {
                if (!mqttConnected) {
                    showError('Robot is not connected! Please check MQTT connection.');
                    return;
                }

                const tableNum = parseInt(tableNumber);
                if (!tableNum || tableNum < 1) {
                    showError('Please enter a valid table number');
                    return;
                }

                showSuccessMessage(`‚è≥ Sending robot to table ${tableNum}...`);

                if (socket && socket.connected) {
                    socket.emit('robot_goto_table', { tableNumber: tableNum });
                } else {
                    const response = await fetch(`/api/mqtt/robot/goto-table/${tableNum}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                    
                    if (!response.ok) {
                        if (response.status === 401) {
                            window.location.href = '/login';
                            return;
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    if (!result.success) {
                        throw new Error(result.message);
                    }
                    
                    showSuccessMessage(`ü§ñ Robot sent to table ${tableNum}`);
                }
                
                console.log(`‚úÖ Robot sent to table ${tableNum} by ${currentUser.username}`);
                
            } catch (error) {
                console.error('Error sending robot:', error);
                if (error.message.includes('401') || error.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    showError(`Error sending robot: ${error.message}`);
                }
            }
        }

        async function emergencyStopRobot() {
            if (!currentUser) {
                showError('Authentication required');
                return;
            }

            try {
                if (!mqttConnected) {
                    showError('Robot is not connected!');
                    return;
                }

                if (!confirm('Are you sure you want to stop the robot?')) {
                    return;
                }

                showSuccessMessage('‚è≥ Sending emergency stop command...');

                const response = await fetch('/api/mqtt/emergency-stop', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        window.location.href = '/login';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.success) {
                    showSuccessMessage('üö® Emergency stop activated');
                } else {
                    throw new Error(result.message);
                }
                
                console.log(`üö® Emergency stop triggered by ${currentUser.username}`);
                
            } catch (error) {
                console.error('Emergency stop error:', error);
                if (error.message.includes('401') || error.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    showError(`Emergency stop error: ${error.message}`);
                }
            }
        }

        function showSuccessMessage(message) {
            showMessage(message, '#48bb78');
        }

        function showWarningMessage(message) {
            showMessage(message, '#ed8936');
        }

        function showMessage(message, color) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${color};
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                z-index: 1001;
                font-weight: 500;
                max-width: 400px;
                text-align: center;
                transition: opacity 0.3s ease, transform 0.3s ease;
            `;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                if (document.body.contains(messageDiv)) {
                    messageDiv.style.opacity = '0';
                    messageDiv.style.transform = 'translateX(-50%) translateY(-20px)';
                    setTimeout(() => {
                        if (document.body.contains(messageDiv)) {
                            document.body.removeChild(messageDiv);
                        }
                    }, 300);
                }
            }, color === '#48bb78' ? 3000 : 4000);
        }

        function updateOrderCard(orderId) {
            const orderCard = document.querySelector(`[data-order-id="${orderId}"]`);
            if (orderCard) {
                const order = allOrders.find(o => o.id == orderId);
                if (order) {
                    const newCardHTML = createOrderCard(order);
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newCardHTML;
                    const newCard = tempDiv.firstElementChild;
                    
                    orderCard.parentNode.replaceChild(newCard, orderCard);
                }
            }
        }

        function simulateRobotDelivery(orderId) {
            // This function simulates robot starting delivery
            if (deliveryStates[orderId] !== 'delivering') {
                deliveryStates[orderId] = 'delivering';
                showSuccessMessage(`üöõ [SIMULATION] Robot started delivering order #${orderId}`);
                updateOrderCard(orderId);
                
                // Simulate delivery completion after 10 seconds
                setTimeout(() => {
                    if (deliveryStates[orderId] === 'delivering') {
                        delete deliveryStates[orderId];
                        updateOrderStatus(orderId, 'delivered');
                        showSuccessMessage(`‚úÖ [SIMULATION] Robot completed delivery for order #${orderId}`);
                    }
                }, 10000);
            }
        }

        async function fetchOrders() {
            if (!currentUser) return;

            try {
                showLoading(true);
                hideError();
                
                const response = await fetch(`${API_BASE}/all`);
                
                if (!response.ok) {
                    if (response.status === 401) {
                        window.location.href = '/login';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    const newOrders = data.orders || [];
                    
                    if (lastOrderCount > 0 && newOrders.length > lastOrderCount) {
                        const latestOrder = newOrders[0];
                        showNewOrderNotification(latestOrder);
                    }
                    
                    lastOrderCount = newOrders.length;
                    allOrders = newOrders;
                    updateStats();
                    filterOrdersByStatus(currentFilter);
                } else {
                    throw new Error(data.message || 'Failed to fetch orders');
                }
            } catch (error) {
                console.error('Error fetching orders:', error);
                if (error.message.includes('401') || error.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    showError(`Error loading orders: ${error.message}`);
                    allOrders = [];
                }
            } finally {
                showLoading(false);
            }
        }

        function displayOrders(orders) {
            const container = document.getElementById('ordersContainer');
            
            if (orders.length === 0) {
                let message = 'No orders found';
                if (currentFilter !== 'all') {
                    const filterLabels = {
                        'pending': 'pending',
                        'preparing': 'preparing',
                        'ready': 'ready',
                        'delivered': 'delivered',
                        'cancelled': 'cancelled'
                    };
                    message = `No ${filterLabels[currentFilter]} orders found`;
                }
                
                container.innerHTML = `
                    <div class="no-orders">
                        <h3>${message}</h3>
                        <p>No orders match the current filter</p>
                    </div>
                `;
                return;
            }

            const ordersHTML = orders.map(order => createOrderCard(order)).join('');
            container.innerHTML = `<div class="orders-grid">${ordersHTML}</div>`;
        }

        function createOrderCard(order) {
            let items = [];
            try {
                items = Array.isArray(order.items) ? order.items : JSON.parse(order.items || '[]');
            } catch (e) {
                items = [];
            }
            
            const itemsHTML = items.map(item => `
                <div class="item">
                    <div>
                        <span class="item-name">${item.name || 'Unknown Item'}</span>
                        <span class="item-quantity">x${item.quantity || item.count || 1}</span>
                    </div>
                    <div class="item-price">${(item.price || 0).toFixed(2)}</div>
                </div>
            `).join('');

            const createdDate = new Date(order.created_at);
            const updatedDate = new Date(order.updated_at);

            let actionButtons = '';
            switch(order.status) {
                case 'pending':
                    actionButtons = `
                        <button class="action-btn btn-confirm" onclick="updateOrderStatus(${order.id}, 'preparing')">
                            ‚úÖ Confirm & Start Preparing
                        </button>
                        <button class="action-btn btn-cancel" onclick="updateOrderStatus(${order.id}, 'cancelled')">
                            ‚ùå Cancel Order
                        </button>
                    `;
                    break;
                case 'preparing':
                    actionButtons = `
                        <button class="action-btn btn-ready" onclick="updateOrderStatus(${order.id}, 'ready')">
                            üçΩÔ∏è Ready for Delivery
                            ${mqttConnected ? '(Auto send to robot)' : '‚ö†Ô∏è Robot offline'}
                        </button>
                        <div class="mqtt-status-inline ${mqttConnected ? 'connected' : 'disconnected'}">
                            ${mqttConnected ? 
                                'ü§ñ Robot connected - Auto send enabled' : 
                                '‚ö†Ô∏è Robot offline - Auto send disabled'
                            }
                        </div>
                    `;
                    break;
                case 'ready':
                    const isDelivering = deliveryStates[order.id] === 'delivering';
                    actionButtons = `
                        <button class="action-btn ${isDelivering ? 'btn-waiting' : 'btn-delivered'}" 
                                onclick="${isDelivering ? '' : `updateOrderStatus(${order.id}, 'delivered')`}"
                                ${isDelivering ? 'disabled' : ''}>
                            ${isDelivering ? '‚è≥ Waiting for Delivery...' : 'üöÄ Mark as Delivered'}
                        </button>
                        <button class="action-btn btn-resend-robot" onclick="sendOrderToRobot(${order.id})" 
                                ${!mqttConnected ? 'disabled title="Robot not connected"' : ''}>
                            ü§ñ Resend to Robot
                        </button>
                        <button class="action-btn btn-goto-table" onclick="sendRobotToTable(${order.tableId})"
                                ${!mqttConnected ? 'disabled title="Robot not connected"' : ''}>
                            üìç Send Robot to Table ${order.tableId}
                        </button>
                        <div class="robot-delivery-status">
                            ${isDelivering ? 
                                'üöõ Robot is delivering...' : 
                                (mqttConnected ? '‚úÖ Robot ready for delivery' : '‚ùå Robot unavailable')
                            }
                        </div>
                    `;
                    break;
                case 'delivered':
                case 'cancelled':
                    actionButtons = `
                        <div style="text-align: center; color: #666; font-style: italic;">
                            Order ${order.status === 'delivered' ? 'delivered' : 'cancelled'}
                            ${order.status === 'delivered' ? '‚úÖ' : '‚ùå'}
                        </div>
                    `;
                    break;
            }

            return `
                <div class="order-card" data-order-id="${order.id}">
                    <div class="order-header">
                        <div class="order-id">Order #${order.id}</div>
                        <div class="order-status status-${order.status}">${getStatusText(order.status)}</div>
                    </div>
                    
                    <div class="order-info">
                        <div class="info-row">
                            <span class="info-label">Table:</span>
                            <span class="info-value">Table ${order.tableId}</span>
                        </div>
                        ${order.tableLocation ? `
                            <div class="info-row">
                                <span class="info-label">Location:</span>
                                <span class="info-value">${order.tableLocation}</span>
                            </div>
                        ` : ''}
                        ${order.restaurantId ? `
                            <div class="info-row">
                                <span class="info-label">Restaurant:</span>
                                <span class="info-value">${order.restaurantId}</span>
                            </div>
                        ` : ''}
                    </div>

                    <div class="order-items">
                        <div class="items-title">Order Items:</div>
                        ${itemsHTML || '<div>No items found</div>'}
                    </div>

                    <div class="order-total">
                        <div class="total-amount">Total: ${parseFloat(order.totalPrice || 0).toFixed(2)}</div>
                    </div>

                    <div class="order-actions">
                        ${actionButtons}
                    </div>

                    <div class="order-time">
                        <div>Created: ${createdDate.toLocaleDateString()} ${createdDate.toLocaleTimeString()}</div>
                        ${order.updated_at !== order.created_at ? `
                            <div>Updated: ${updatedDate.toLocaleDateString()} ${updatedDate.toLocaleTimeString()}</div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function filterOrdersByStatus(status) {
            let filteredOrders;
            if (status === 'all') {
                filteredOrders = allOrders;
            } else {
                filteredOrders = allOrders.filter(order => order.status === status);
            }
            
            displayOrders(filteredOrders);
        }

        function filterOrders(status, buttonElement) {
            currentFilter = status;
            
            document.querySelectorAll('.controls .btn').forEach(btn => btn.classList.remove('active'));
            if (buttonElement) {
                buttonElement.classList.add('active');
            }
            
            filterOrdersByStatus(status);
        }

        function updateStats() {
            const totalOrders = allOrders.length;
            const pendingOrders = allOrders.filter(order => 
                ['pending', 'preparing', 'ready'].includes(order.status)
            ).length;
            const completedOrders = allOrders.filter(order => 
                order.status === 'delivered'
            ).length;
            const totalRevenue = allOrders
                .filter(order => order.status === 'delivered')
                .reduce((sum, order) => sum + parseFloat(order.totalPrice || 0), 0);

            document.getElementById('totalOrders').textContent = totalOrders;
            document.getElementById('pendingOrders').textContent = pendingOrders;
            document.getElementById('completedOrders').textContent = completedOrders;
            document.getElementById('totalRevenue').textContent = `${totalRevenue.toFixed(2)}`;

            updateMQTTStatus();
        }

        function updateMQTTStatus() {
            let mqttStatusElement = document.getElementById('mqttStatus');
            if (!mqttStatusElement) {
                mqttStatusElement = document.createElement('div');
                mqttStatusElement.id = 'mqttStatus';
                mqttStatusElement.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    padding: 8px 12px;
                    border-radius: 5px;
                    font-weight: bold;
                    z-index: 1000;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    ${mqttConnected ? 
                        'background: #48bb78; color: white;' : 
                        'background: #e53e3e; color: white;'
                    }
                `;
                document.body.appendChild(mqttStatusElement);
                
                mqttStatusElement.addEventListener('click', showMQTTDetails);
            }
            
            mqttStatusElement.textContent = mqttConnected ? 'ü§ñ Robot Connected' : '‚ö†Ô∏è Robot Offline';
            mqttStatusElement.style.background = mqttConnected ? '#48bb78' : '#e53e3e';
            mqttStatusElement.title = mqttConnected ? 
                'Robot connected - Auto send enabled' : 
                'Robot not connected - Auto send disabled';
        }

        function showMQTTDetails() {
            const details = `
                MQTT Status: ${mqttConnected ? 'Connected ‚úÖ' : 'Disconnected ‚ùå'}
                
                ${mqttConnected ? 
                    '‚Ä¢ Auto order sending enabled\n‚Ä¢ Remote robot control available\n‚Ä¢ Real-time status updates active' :
                    '‚Ä¢ Auto order sending disabled\n‚Ä¢ Robot control unavailable\n‚Ä¢ Limited status updates'
                }
            `;
            
            alert(details);
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            
            setTimeout(() => {
                hideError();
            }, 5000);
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function refreshOrders() {
            fetchOrders();
        }

        function updateDeliveryStatesDisplay() {
            const display = document.getElementById('deliveryStatesDisplay');
            if (!display) return;

            const activeDeliveries = Object.keys(deliveryStates);
            
            if (activeDeliveries.length === 0) {
                display.innerHTML = '<p style="color: #666;">No active deliveries</p>';
            } else {
                const deliveriesHTML = activeDeliveries.map(orderId => {
                    const order = allOrders.find(o => o.id == orderId);
                    const orderInfo = order ? `Order #${orderId} (Table ${order.tableId})` : `Order #${orderId}`;
                    return `
                        <div style="background: #fff; padding: 10px; margin: 5px 0; border-radius: 5px; border-left: 4px solid #ed8936;">
                            <strong>${orderInfo}</strong> - Status: ${deliveryStates[orderId]}
                            <button onclick="delete deliveryStates[${orderId}]; updateDeliveryStatesDisplay(); updateOrderCard(${orderId});" 
                                    style="margin-left: 10px; padding: 2px 8px; background: #e53e3e; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                Cancel Delivery
                            </button>
                        </div>
                    `;
                }).join('');
                
                display.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <strong>Active Deliveries: ${activeDeliveries.length}</strong>
                    </div>
                    ${deliveriesHTML}
                `;
            }
        }

        function switchTab(tabId, buttonElement) {
            document.querySelectorAll('.controls .btn').forEach(btn => btn.classList.remove('active'));
            if (buttonElement) buttonElement.classList.add('active');

            document.querySelectorAll('.content-section').forEach(sec => sec.classList.remove('active'));
            const section = document.getElementById(tabId);
            if (section) section.classList.add('active');

            if (['orders', 'pending', 'preparing', 'ready', 'delivered'].includes(tabId)) {
                currentFilter = tabId === 'orders' ? 'all' : tabId;
                fetchOrders();
            }
            if (tabId === 'users' && currentUser && currentUser.role === 'admin') {
                loadUsers();
            }
            if (tabId === 'testing') {
                updateDeliveryStatesDisplay();
            }
        }

        // User Management Functions (Admin only)
        async function loadUsers() {
            if (!currentUser || currentUser.role !== 'admin') {
                document.getElementById('usersTable').innerHTML = `<tr><td colspan='4'>Access denied</td></tr>`;
                return;
            }

            try {
                const res = await fetch(`${API_USERS}/all`);
                if (!res.ok) {
                    if (res.status === 401) {
                        window.location.href = '/login';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                
                const data = await res.json();
                const tbody = document.getElementById('usersTable');
                
                if (data.success) {
                    tbody.innerHTML = data.users.map(u => `
                        <tr>
                            <td>${u.id}</td>
                            <td>${u.name || 'N/A'}</td>
                            <td>${u.role || 'N/A'}</td>
                            <td>
                                <button class="btn-action btn-edit" onclick="editUser(${u.id})">Edit</button>
                                <button class="btn-action btn-delete" onclick="deleteUser(${u.id})">Delete</button>
                            </td>
                        </tr>
                    `).join('');
                    document.getElementById('managementUsers').textContent = data.users.length;
                } else {
                    tbody.innerHTML = `<tr><td colspan='4'>${data.message || 'Error loading users'}</td></tr>`;
                }
            } catch (e) {
                console.error('Error loading users:', e);
                if (e.message.includes('401') || e.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    document.getElementById('usersTable').innerHTML = `<tr><td colspan='4'>Error loading users: ${e.message}</td></tr>`;
                }
            }
        }

        async function addUser() {
            if (!currentUser || currentUser.role !== 'admin') {
                showError('Admin access required');
                return;
            }

            const name = prompt('Enter user name:');
            const role = prompt('Enter role (customer, cashier, chef, robot, admin):');
            if (!name || !role) return;
            
            try {
                const response = await fetch(`${API_USERS}/add`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, role })
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        window.location.href = '/login';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.success) {
                    showSuccessMessage('User added successfully');
                    loadUsers();
                } else {
                    showError(result.message || 'Failed to add user');
                }
            } catch (error) {
                if (error.message.includes('401') || error.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    showError(`Error adding user: ${error.message}`);
                }
            }
        }

        async function deleteUser(id) {
            if (!currentUser || currentUser.role !== 'admin') {
                showError('Admin access required');
                return;
            }

            if (!confirm('Are you sure you want to delete this user?')) return;
            
            try {
                const response = await fetch(`${API_USERS}/delete/${id}`, { 
                    method: 'DELETE' 
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        window.location.href = '/login';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.success) {
                    showSuccessMessage('User deleted successfully');
                    loadUsers();
                } else {
                    showError(result.message || 'Failed to delete user');
                }
            } catch (error) {
                if (error.message.includes('401') || error.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    showError(`Error deleting user: ${error.message}`);
                }
            }
        }

        async function editUser(id) {
            if (!currentUser || currentUser.role !== 'admin') {
                showError('Admin access required');
                return;
            }

            const newName = prompt('Enter new name:');
            const newRole = prompt('Enter new role:');
            if (!newName || !newRole) return;
            
            try {
                const response = await fetch(`${API_USERS}/update/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName, role: newRole })
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        window.location.href = '/login';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                if (result.success) {
                    showSuccessMessage('User updated successfully');
                    loadUsers();
                } else {
                    showError(result.message || 'Failed to update user');
                }
            } catch (error) {
                if (error.message.includes('401') || error.message.includes('unauthorized')) {
                    window.location.href = '/login';
                } else {
                    showError(`Error updating user: ${error.message}`);
                }
            }
        }

        // WebSocket Connection with better error handling
        function connectWebSocket() {
            if (connectionAttempts >= maxConnectionAttempts) {
                console.log('Max connection attempts reached. Stopping reconnection.');
                showError('Unable to connect to server after multiple attempts');
                return;
            }

            try {
                socket = io(window.location.origin, {
                    reconnection: true,
                    reconnectionDelay: 2000,
                    reconnectionAttempts: 5,
                    timeout: 20000
                });
                
                socket.on('connect', () => {
                    console.log('Connected to WebSocket');
                    connectionAttempts = 0;
                });
                
                socket.on('connection_confirmed', (data) => {
                    console.log('WebSocket connection confirmed:', data);
                    mqttConnected = data.mqtt_connected || false;
                    updateMQTTStatus();
                });
                
                socket.on('mqtt_status', (data) => {
                    console.log('MQTT Status Update:', data);
                    const oldStatus = mqttConnected;
                    mqttConnected = data.connected || false;
                    
                    if (oldStatus !== mqttConnected) {
                        if (mqttConnected) {
                            showSuccessMessage('Robot connected - Auto send enabled');
                        } else {
                            showWarningMessage('Robot disconnected - Auto send disabled');
                        }
                    }
                    
                    updateMQTTStatus();
                });
                
                socket.on('new_order_created', (data) => {
                    console.log('New order received via WebSocket:', data);
                    if (data.order) {
                        showNewOrderNotification(data.order);
                        setTimeout(fetchOrders, 1000);
                    }
                });
                
                socket.on('order_status_updated', (data) => {
                    console.log('Order status updated:', data);
                    
                    if (data.automated) {
                        showSuccessMessage(`Order #${data.orderId} updated by robot to "${getStatusText(data.newStatus)}"`);
                    }
                    
                    setTimeout(fetchOrders, 500);
                });
                
                socket.on('robot_status', (data) => {
                    console.log('Robot status:', data);
                    
                    // Handle delivery started
                    if (data.status === 'delivering' && data.orderId) {
                        deliveryStates[data.orderId] = 'delivering';
                        showSuccessMessage(`Robot started delivering order #${data.orderId}`);
                        updateOrderCard(data.orderId);
                    }
                    
                    // Handle other robot status updates
                    if (data.status || data.message) {
                        showSuccessMessage(`Robot status: ${data.status || data.message}`);
                    }
                });
                
                socket.on('delivery_complete', (data) => {
                    console.log('Delivery complete:', data);
                    
                    const orderId = data.order_id || data.orderId;
                    if (orderId) {
                        // Remove from delivery states
                        delete deliveryStates[orderId];
                        
                        // Automatically update order status to delivered
                        updateOrderStatus(orderId, 'delivered');
                        
                        showSuccessMessage(`Delivery complete: Order #${orderId}`);
                        playNotificationSound();
                    }
                });

                socket.on('robot_delivery_started', (data) => {
                    console.log('Robot delivery started:', data);
                    const orderId = data.orderId || data.order_id;
                    if (orderId) {
                        deliveryStates[orderId] = 'delivering';
                        showSuccessMessage(`Robot started delivering order #${orderId}`);
                        updateOrderCard(orderId);
                    }
                });

                socket.on('kitchen_notification_sent', (data) => {
                    console.log('Kitchen notified:', data);
                    showSuccessMessage(`Kitchen notified: Order #${data.orderId}`);
                });

                socket.on('customer_notification_sent', (data) => {
                    console.log('Customer notified:', data);
                    showSuccessMessage(`Customer notified: Order #${data.orderId}`);
                });
                
                socket.on('emergency_alert', (data) => {
                    console.log('Emergency alert:', data);
                    showError(`Emergency Alert: ${data.reason || data.message}`);
                });
                
                socket.on('order_sent_to_robot', (data) => {
                    if (data.success) {
                        showSuccessMessage(`Order #${data.orderId} successfully sent to robot`);
                    } else {
                        showError(`Error sending order: ${data.error}`);
                    }
                });
                
                socket.on('robot_command_sent', (data) => {
                    if (data.success) {
                        if (data.command === 'goto_table') {
                            showSuccessMessage(`Robot sent to table ${data.tableNumber}`);
                        }
                    } else {
                        showError(`Error sending command: ${data.error}`);
                    }
                });
                
                socket.on('connect_error', (error) => {
                    console.error('WebSocket connection error:', error);
                    connectionAttempts++;
                    if (connectionAttempts < maxConnectionAttempts) {
                        showWarningMessage(`Connection attempt ${connectionAttempts}/${maxConnectionAttempts} failed. Retrying...`);
                    }
                });
                
                socket.on('disconnect', () => {
                    console.log('Disconnected from WebSocket');
                    mqttConnected = false;
                    updateMQTTStatus();
                    
                    if (connectionAttempts < maxConnectionAttempts) {
                        showWarningMessage('WebSocket disconnected - attempting to reconnect...');
                    }
                });
                
            } catch (error) {
                console.error('WebSocket connection failed:', error);
                connectionAttempts++;
                mqttConnected = false;
                updateMQTTStatus();
                
                if (connectionAttempts < maxConnectionAttempts) {
                    setTimeout(() => connectWebSocket(), 5000);
                }
            }
        }

        function addRobotControlButtons() {
            const header = document.querySelector('.header');
            if (header) {
                const robotControls = document.createElement('div');
                robotControls.style.cssText = `
                    margin-top: 15px;
                    display: flex;
                    gap: 10px;
                    justify-content: center;
                    flex-wrap: wrap;
                `;
                
                robotControls.innerHTML = `
                    <button class="btn" onclick="emergencyStopRobot()" 
                            style="background: #e53e3e;"
                            ${!mqttConnected ? 'disabled title="Robot not connected"' : ''}>
                        Emergency Stop
                    </button>
                    <input type="number" id="gotoTableInput" placeholder="Table #" min="1" max="50" 
                        style="padding: 8px; border-radius: 5px; border: 1px solid #ccc; width: 120px;"
                        ${!mqttConnected ? 'disabled' : ''}>
                    <button class="btn" onclick="sendRobotToTable(document.getElementById('gotoTableInput').value)"
                            style="background: #3182ce;"
                            ${!mqttConnected ? 'disabled title="Robot not connected"' : ''}>
                        Send to Table
                    </button>
                `;
                
                header.appendChild(robotControls);
                
                const updateRobotControls = () => {
                    const emergencyBtn = robotControls.querySelector('button[onclick="emergencyStopRobot()"]');
                    const gotoInput = robotControls.querySelector('#gotoTableInput');
                    const gotoBtn = robotControls.querySelector('button[onclick*="sendRobotToTable"]');
                    
                    [emergencyBtn, gotoBtn].forEach(btn => {
                        if (mqttConnected) {
                            btn.removeAttribute('disabled');
                            btn.removeAttribute('title');
                        } else {
                            btn.setAttribute('disabled', '');
                            btn.setAttribute('title', 'Robot not connected');
                        }
                    });
                    
                    if (mqttConnected) {
                        gotoInput.removeAttribute('disabled');
                    } else {
                        gotoInput.setAttribute('disabled', '');
                    }
                };
                
                updateRobotControls();
                setInterval(updateRobotControls, 1000);
            }
        }

        // Auto-refresh every 15 minutes
        setInterval(fetchOrders, 900000);

        // Initialize when page loads
        window.addEventListener('load', async () => {
            // Check authentication first
            const authOk = await checkAuth();
            if (!authOk) return;
            
            fetchOrders();
            connectWebSocket();
            addRobotControlButtons();
            
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        });

        // Handle page visibility for security
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && currentUser) {
                // Page became visible, check auth status
                checkAuth();
            }
        });
            </script>
            <script src="/static/js/role-access-control.js"></script>
            <script>
                           
                // ÿ™ÿπÿ±€åŸÅ ÿØÿ≥ÿ™ÿ±ÿ≥€å‚ÄåŸáÿß€å Ÿáÿ± role
                const rolePermissions = {
                    admin: {
                        buttons: ['all', 'pending', 'preparing', 'ready', 'delivered', 'testing', 'users'],
                        canViewAllStats: true,
                        canControlRobot: true,
                        canManageOrders: true,
                        canAccessUserManagement: true
                    },
                    kitchen: {
                        buttons: ['preparing'],
                        canViewAllStats: false,
                        canControlRobot: false,
                        canManageOrders: true,
                        defaultFilter: 'preparing',
                        hideStats: ['managementUsers', 'totalRevenue']
                    },
                    manager: {
                        buttons: ['all', 'pending', 'preparing', 'ready', 'delivered'],
                        canViewAllStats: true,
                        canControlRobot: false,
                        canManageOrders: true,
                        defaultFilter: 'pending'
                    },
                    robot: {
                        buttons: ['ready', 'delivered'],
                        canViewAllStats: false,
                        canControlRobot: true,
                        canManageOrders: false,
                        defaultFilter: 'ready',
                        hideStats: ['managementUsers', 'totalRevenue']
                    },
                    cashier: {
                        buttons: ['all', 'pending'],
                        canViewAllStats: false,
                        canControlRobot: false,
                        canManageOrders: true,
                        defaultFilter: 'pending',
                        hideStats: ['managementUsers']
                    }
                };

                // ÿßÿπŸÖÿßŸÑ ŸÖÿ≠ÿØŸàÿØ€åÿ™‚ÄåŸáÿß€å role-based
                function applyRoleBasedAccess(userRole) {
                    console.log('Applying role-based access for:', userRole);
                    
                    const permissions = rolePermissions[userRole];
                    if (!permissions) {
                        console.error('Unknown user role:', userRole);
                        return;
                    }

                    // ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ ŸÜÿ¥ÿßŸÜ⁄Øÿ± role ÿ®Ÿá badge
                    const userBadge = document.getElementById('userBadge');
                    if (userBadge && !userBadge.innerHTML.includes('role-indicator')) {
                        const roleIndicator = document.createElement('span');
                        roleIndicator.className = `role-indicator ${userRole}`;
                        roleIndicator.textContent = userRole.toUpperCase();
                        userBadge.appendChild(roleIndicator);
                    }

                    // ŸÖÿÆŸÅ€å/ŸÜŸÖÿß€åÿ¥ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ŸÅ€åŸÑÿ™ÿ±
                    const controlButtons = document.querySelectorAll('.controls .btn');
                    controlButtons.forEach(button => {
                        const buttonText = button.textContent.trim().toLowerCase();
                        let buttonType = '';
                        
                        if (buttonText.includes('all orders')) buttonType = 'all';
                        else if (buttonText.includes('pending')) buttonType = 'pending';
                        else if (buttonText.includes('preparing')) buttonType = 'preparing';
                        else if (buttonText.includes('ready')) buttonType = 'ready';
                        else if (buttonText.includes('delivered')) buttonType = 'delivered';
                        else if (buttonText.includes('testing')) buttonType = 'testing';
                        else if (buttonText.includes('users')) buttonType = 'users';

                        if (permissions.buttons.includes(buttonType)) {
                            button.style.display = 'inline-block';
                        } else {
                            button.style.display = 'none';
                        }
                    });

                    // ŸÖÿÆŸÅ€å ⁄©ÿ±ÿØŸÜ ÿ¢ŸÖÿßÿ±Ÿáÿß€å ÿ∫€åÿ±ŸÖÿ¨ÿßÿ≤
                    if (permissions.hideStats) {
                        permissions.hideStats.forEach(statId => {
                            const statElement = document.getElementById(statId);
                            if (statElement) {
                                const statCard = statElement.closest('.stat-card');
                                if (statCard) {
                                    statCard.style.opacity = '0.5';
                                    statCard.title = 'Access restricted for your role';
                                    statElement.textContent = '-';
                                }
                            }
                        });
                    }

                    // ŸÖÿ≠ÿØŸàÿØ ⁄©ÿ±ÿØŸÜ ⁄©ŸÜÿ™ÿ±ŸÑ‚ÄåŸáÿß€å ÿ±ÿ®ÿßÿ™
                    if (!permissions.canControlRobot) {
                        setTimeout(() => {
                            const robotControls = document.querySelectorAll('button[onclick*="emergencyStopRobot"], button[onclick*="sendRobotToTable"], #gotoTableInput');
                            robotControls.forEach(control => {
                                control.disabled = true;
                                control.title = 'Access denied for your role';
                                control.style.opacity = '0.4';
                            });
                        }, 1000);
                    }

                    // ÿ™ŸÜÿ∏€åŸÖ ŸÅ€åŸÑÿ™ÿ± Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂
                    if (permissions.defaultFilter) {
                        setTimeout(() => {
                            filterOrders(permissions.defaultFilter);
                            // ŸÅÿπÿßŸÑ ⁄©ÿ±ÿØŸÜ ÿØ⁄©ŸÖŸá ŸÖŸÜÿßÿ≥ÿ®
                            const targetButton = Array.from(controlButtons).find(btn => 
                                btn.getAttribute('onclick')?.includes(`'${permissions.defaultFilter}'`)
                            );
                            if (targetButton) {
                                controlButtons.forEach(btn => btn.classList.remove('active'));
                                targetButton.classList.add('active');
                            }
                        }, 500);
                    }
                }
                 function setupKitchenView(userRole) {
                        if (userRole === 'kitchen') {
                            // ŸÅŸÇÿ∑ ŸÜŸÖÿß€åÿ¥ preparing orders
                            filterOrders('preparing');
                            
                            // ŸÖÿÆŸÅ€å ⁄©ÿ±ÿØŸÜ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ÿ∫€åÿ±ÿ∂ÿ±Ÿàÿ±€å
                            hideUnnecessaryButtons();
                            
                            // ÿ™ÿ∫€å€åÿ± ÿπŸÜŸàÿßŸÜ ÿµŸÅÿ≠Ÿá
                            document.querySelector('h1').textContent = 'Kitchen Orders - Preparing';
                            
                            // ÿßÿ∂ÿßŸÅŸá ⁄©ÿ±ÿØŸÜ timer ÿ®ÿ±ÿß€å Ÿáÿ± ÿ≥ŸÅÿßÿ±ÿ¥
                            addPreparationTimers();
                        }
                    }

                function addPreparationTimers() {
                        const preparingCards = document.querySelectorAll('.order-card[data-status="preparing"]');
                        preparingCards.forEach(card => {
                            const createdTime = card.dataset.created;
                            const timerElement = document.createElement('div');
                            timerElement.className = 'preparation-timer';
                            card.appendChild(timerElement);
                            
                            // ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å timer Ÿáÿ± ÿ´ÿßŸÜ€åŸá
                            updateTimer(timerElement, createdTime);
                        });
                    }

                // Override ⁄©ÿ±ÿØŸÜ ÿ™Ÿàÿßÿ®ÿπ ÿ≠ÿ≥ÿßÿ≥
                const originalFunctions = {};

                function setupSecureOverrides() {
                    // ŸÖÿ≠ÿßŸÅÿ∏ÿ™ ÿßÿ≤ updateOrderStatus
                    if (!originalFunctions.updateOrderStatus) {
                        originalFunctions.updateOrderStatus = window.updateOrderStatus;
                        window.updateOrderStatus = function(orderId, newStatus) {
                            const permissions = rolePermissions[currentUser?.role];
                            if (!permissions?.canManageOrders) {
                                showError('You do not have permission to manage orders');
                                return Promise.resolve();
                            }
                            return originalFunctions.updateOrderStatus.call(this, orderId, newStatus);
                        };
                    }

                    // ŸÖÿ≠ÿßŸÅÿ∏ÿ™ ÿßÿ≤ ⁄©ŸÜÿ™ÿ±ŸÑ‚ÄåŸáÿß€å ÿ±ÿ®ÿßÿ™
                    if (!originalFunctions.sendOrderToRobot) {
                        originalFunctions.sendOrderToRobot = window.sendOrderToRobot;
                        window.sendOrderToRobot = function(orderId) {
                            const permissions = rolePermissions[currentUser?.role];
                            if (!permissions?.canControlRobot) {
                                showError('You do not have permission to control the robot');
                                return Promise.resolve();
                            }
                            return originalFunctions.sendOrderToRobot.call(this, orderId);
                        };
                    }

                    if (!originalFunctions.sendRobotToTable) {
                        originalFunctions.sendRobotToTable = window.sendRobotToTable;
                        window.sendRobotToTable = function(tableNumber) {
                            const permissions = rolePermissions[currentUser?.role];
                            if (!permissions?.canControlRobot) {
                                showError('You do not have permission to control the robot');
                                return Promise.resolve();
                            }
                            return originalFunctions.sendRobotToTable.call(this, tableNumber);
                        };
                    }

                    if (!originalFunctions.emergencyStopRobot) {
                        originalFunctions.emergencyStopRobot = window.emergencyStopRobot;
                        window.emergencyStopRobot = function() {
                            const permissions = rolePermissions[currentUser?.role];
                            if (!permissions?.canControlRobot) {
                                showError('You do not have permission to control the robot');
                                return Promise.resolve();
                            }
                            return originalFunctions.emergencyStopRobot.call(this);
                        };
                    }
                }

                // ÿßÿµŸÑÿßÿ≠ ÿ™ÿßÿ®ÿπ updateUIForUser
                const originalUpdateUIForUser = window.updateUIForUser;
                window.updateUIForUser = function() {
                    if (originalUpdateUIForUser) {
                        originalUpdateUIForUser.call(this);
                    }
                    
                    if (currentUser && currentUser.role) {
                        applyRoleBasedAccess(currentUser.role);
                        setupSecureOverrides();
                    }
                };
    </script>
</body>
</html>